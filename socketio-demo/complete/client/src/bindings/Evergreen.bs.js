// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as EvergreenUi from "evergreen-ui";

function unfold(x, f) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

function colorToStr(color) {
  switch (color) {
    case /* Gray900 */0 :
        return "gray900";
    case /* Gray800 */1 :
        return "gray800";
    case /* Gray700 */2 :
        return "gray700";
    case /* Gray600 */3 :
        return "gray600";
    case /* Gray500 */4 :
        return "gray500";
    case /* Gray400 */5 :
        return "gray400";
    case /* Gray300 */6 :
        return "gray300";
    case /* Gray200 */7 :
        return "gray200";
    case /* Gray100 */8 :
        return "gray100";
    case /* Gray90 */9 :
        return "gray90";
    case /* Gray75 */10 :
        return "gray75";
    case /* Gray50 */11 :
        return "gray50";
    case /* Blue900 */12 :
        return "blue900";
    case /* Blue800 */13 :
        return "blue800";
    case /* Blue700 */14 :
        return "blue700";
    case /* Blue600 */15 :
        return "blue600";
    case /* Blue500 */16 :
        return "blue500";
    case /* Blue400 */17 :
        return "blue400";
    case /* Blue300 */18 :
        return "blue300";
    case /* Blue200 */19 :
        return "blue200";
    case /* Blue100 */20 :
        return "blue100";
    case /* Blue50 */21 :
        return "blue50";
    case /* Blue25 */22 :
        return "blue25";
    case /* Red700 */23 :
        return "red700";
    case /* Red600 */24 :
        return "red600";
    case /* Red500 */25 :
        return "red500";
    case /* Red300 */26 :
        return "red300";
    case /* Red100 */27 :
        return "red100";
    case /* Red25 */28 :
        return "red25";
    case /* Green900 */29 :
        return "green900";
    case /* Green800 */30 :
        return "green800";
    case /* Green700 */31 :
        return "green700";
    case /* Green600 */32 :
        return "green600";
    case /* Green500 */33 :
        return "green500";
    case /* Green400 */34 :
        return "green400";
    case /* Green300 */35 :
        return "green300";
    case /* Green200 */36 :
        return "green200";
    case /* Green100 */37 :
        return "green100";
    case /* Green25 */38 :
        return "green25";
    case /* Orange700 */39 :
        return "orange700";
    case /* Orange500 */40 :
        return "orange500";
    case /* Orange100 */41 :
        return "orange100";
    case /* Orange25 */42 :
        return "orange25";
    case /* Purple600 */43 :
        return "purple600";
    case /* Purple100 */44 :
        return "purple100";
    case /* Teal800 */45 :
        return "teal800";
    case /* Teal100 */46 :
        return "teal100";
    case /* Yellow800 */47 :
        return "yellow800";
    case /* Yellow100 */48 :
        return "yellow100";
    case /* Muted */49 :
        return "muted";
    case /* Default */50 :
        return "default";
    case /* Dark */51 :
        return "dark";
    case /* Selected */52 :
        return "selected";
    case /* Tint1 */53 :
        return "tint1";
    case /* Tint2 */54 :
        return "tint2";
    case /* Overlay */55 :
        return "overlay";
    case /* YellowTint */56 :
        return "yellowTint";
    case /* GreenTint */57 :
        return "greenTint";
    case /* OrangeTint */58 :
        return "orangeTint";
    case /* RedTint */59 :
        return "redTint";
    case /* BlueTint */60 :
        return "blueTint";
    case /* PurpleTint */61 :
        return "purpleTint";
    case /* TealTint */62 :
        return "tealTint";
    
  }
}

function appearanceToStr(appearance) {
  switch (appearance) {
    case /* Default */0 :
        return "default";
    case /* Minimal */1 :
        return "minimal";
    case /* Primary */2 :
        return "primary";
    
  }
}

function intentToStr(intent) {
  switch (intent) {
    case /* NoIntent */0 :
        return "none";
    case /* Success */1 :
        return "success";
    case /* Danger */2 :
        return "danger";
    
  }
}

function sizeToStr(size) {
  switch (size) {
    case /* Sm */0 :
        return "small";
    case /* Md */1 :
        return "medium";
    case /* Lg */2 :
        return "large";
    
  }
}

var Binding = {};

function Evergreen$Button(Props) {
  var appearance = Props.appearance;
  var size = Props.size;
  var isLoading = Props.isLoading;
  var isActive = Props.isActive;
  var iconBefore = Props.iconBefore;
  var iconAfter = Props.iconAfter;
  var disabled = Props.disabled;
  var onClick = Props.onClick;
  var className = Props.className;
  var intent = Props.intent;
  var children = Props.children;
  var appearance$1 = unfold(appearance, appearanceToStr);
  var size$1 = unfold(size, sizeToStr);
  var intent$1 = unfold(intent, intentToStr);
  var tmp = {
    children: children
  };
  if (appearance$1 !== undefined) {
    tmp.appearance = appearance$1;
  }
  if (size$1 !== undefined) {
    tmp.size = size$1;
  }
  if (onClick !== undefined) {
    tmp.onClick = Caml_option.valFromOption(onClick);
  }
  if (isLoading !== undefined) {
    tmp.isLoading = isLoading;
  }
  if (isActive !== undefined) {
    tmp.isActive = isActive;
  }
  if (iconBefore !== undefined) {
    tmp.iconBefore = Caml_option.valFromOption(iconBefore);
  }
  if (iconAfter !== undefined) {
    tmp.iconAfter = Caml_option.valFromOption(iconAfter);
  }
  if (disabled !== undefined) {
    tmp.disabled = disabled;
  }
  if (className !== undefined) {
    tmp.className = className;
  }
  if (intent$1 !== undefined) {
    tmp.intent = intent$1;
  }
  return React.createElement(EvergreenUi.Button, tmp);
}

var Button = {
  appearanceToStr: appearanceToStr,
  intentToStr: intentToStr,
  sizeToStr: sizeToStr,
  Binding: Binding,
  make: Evergreen$Button
};

function appearanceToStr$1(appearance) {
  switch (appearance) {
    case /* Default */0 :
        return "default";
    case /* Minimal */1 :
        return "minimal";
    case /* Primary */2 :
        return "primary";
    
  }
}

function intentToStr$1(intent) {
  switch (intent) {
    case /* NoIntent */0 :
        return "none";
    case /* Success */1 :
        return "success";
    case /* Danger */2 :
        return "danger";
    
  }
}

function sizeToStr$1(size) {
  switch (size) {
    case /* Sm */0 :
        return "small";
    case /* Md */1 :
        return "medium";
    case /* Lg */2 :
        return "large";
    
  }
}

var Binding$1 = {};

function Evergreen$IconButton(Props) {
  var appearance = Props.appearance;
  var size = Props.size;
  var isLoading = Props.isLoading;
  var icon = Props.icon;
  var isActive = Props.isActive;
  var disabled = Props.disabled;
  var onClick = Props.onClick;
  var className = Props.className;
  var intent = Props.intent;
  var appearance$1 = unfold(appearance, appearanceToStr$1);
  var size$1 = unfold(size, sizeToStr$1);
  var intent$1 = unfold(intent, intentToStr$1);
  var tmp = {
    icon: icon,
    onClick: onClick
  };
  if (appearance$1 !== undefined) {
    tmp.appearance = appearance$1;
  }
  if (size$1 !== undefined) {
    tmp.size = size$1;
  }
  if (isLoading !== undefined) {
    tmp.isLoading = isLoading;
  }
  if (isActive !== undefined) {
    tmp.isActive = isActive;
  }
  if (disabled !== undefined) {
    tmp.disabled = disabled;
  }
  if (className !== undefined) {
    tmp.className = className;
  }
  if (intent$1 !== undefined) {
    tmp.intent = intent$1;
  }
  return React.createElement(EvergreenUi.IconButton, tmp);
}

var IconButton = {
  appearanceToStr: appearanceToStr$1,
  intentToStr: intentToStr$1,
  sizeToStr: sizeToStr$1,
  Binding: Binding$1,
  make: Evergreen$IconButton
};

function intentToStr$2(intent) {
  switch (intent) {
    case /* NoIntent */0 :
        return "none";
    case /* Success */1 :
        return "success";
    case /* Warning */2 :
        return "warning";
    case /* Danger */3 :
        return "danger";
    
  }
}

var BindingRenderProps = {};

var BindingStr = {};

var BindingNode = {};

function Evergreen$CornerDialog(Props) {
  var children = Props.children;
  var intent = Props.intent;
  var isShown = Props.isShown;
  var title = Props.title;
  var onCloseComplete = Props.onCloseComplete;
  var onOpenComplete = Props.onOpenComplete;
  var hasFooter = Props.hasFooter;
  var onConfirm = Props.onConfirm;
  var confirmLabel = Props.confirmLabel;
  var hasCancel = Props.hasCancel;
  var hasClose = Props.hasClose;
  var onCancel = Props.onCancel;
  var cancelLabel = Props.cancelLabel;
  var width = Props.width;
  var intent$1 = unfold(intent, intentToStr$2);
  var tmp = {
    children: children._0,
    title: title
  };
  if (intent$1 !== undefined) {
    tmp.intent = intent$1;
  }
  if (isShown !== undefined) {
    tmp.isShown = isShown;
  }
  if (onCloseComplete !== undefined) {
    tmp.onCloseComplete = Caml_option.valFromOption(onCloseComplete);
  }
  if (onOpenComplete !== undefined) {
    tmp.onOpenComplete = Caml_option.valFromOption(onOpenComplete);
  }
  if (hasFooter !== undefined) {
    tmp.hasFooter = hasFooter;
  }
  if (onConfirm !== undefined) {
    tmp.onConfirm = Caml_option.valFromOption(onConfirm);
  }
  if (confirmLabel !== undefined) {
    tmp.confirmLabel = confirmLabel;
  }
  if (hasCancel !== undefined) {
    tmp.hasCancel = hasCancel;
  }
  if (hasClose !== undefined) {
    tmp.hasClose = hasClose;
  }
  if (onCancel !== undefined) {
    tmp.onCancel = Caml_option.valFromOption(onCancel);
  }
  if (cancelLabel !== undefined) {
    tmp.cancelLabel = cancelLabel;
  }
  if (width !== undefined) {
    tmp.width = width;
  }
  return React.createElement(EvergreenUi.CornerDialog, tmp);
}

var CornerDialog = {
  intentToStr: intentToStr$2,
  BindingRenderProps: BindingRenderProps,
  BindingStr: BindingStr,
  BindingNode: BindingNode,
  make: Evergreen$CornerDialog
};

function sizeToInt(size) {
  switch (size) {
    case /* Xs3 */0 :
        return [
                100,
                16
              ];
    case /* Xs2 */1 :
        return [
                200,
                16
              ];
    case /* Xs */2 :
        return [
                300,
                16
              ];
    case /* Sm */3 :
        return [
                400,
                16
              ];
    case /* Md */4 :
        return [
                500,
                24
              ];
    case /* Lg */5 :
        return [
                600,
                28
              ];
    case /* Xl */6 :
        return [
                700,
                40
              ];
    case /* Xl2 */7 :
        return [
                800,
                40
              ];
    case /* Xl3 */8 :
        return [
                900,
                52
              ];
    
  }
}

var Binding$2 = {};

function Evergreen$Heading(Props) {
  var text = Props.text;
  var size = Props.size;
  var match = size !== undefined ? sizeToInt(size) : [
      500,
      24
    ];
  return React.createElement(EvergreenUi.Heading, {
              children: text,
              size: match[0],
              marginBottom: match[1]
            });
}

var Heading = {
  sizeToInt: sizeToInt,
  Binding: Binding$2,
  make: Evergreen$Heading
};

function sizeToInt$1(size) {
  switch (size) {
    case /* Sm */0 :
        return 300;
    case /* Md */1 :
        return 400;
    case /* Lg */2 :
        return 500;
    
  }
}

var Binding$3 = {};

function Evergreen$Text(Props) {
  var size = Props.size;
  var children = Props.children;
  var muted = Props.muted;
  var size$1 = unfold(size, sizeToInt$1);
  var color = unfold(muted, (function (m) {
          if (m) {
            return "muted";
          } else {
            return "";
          }
        }));
  var tmp = {
    children: children
  };
  if (size$1 !== undefined) {
    tmp.size = size$1;
  }
  if (color !== undefined) {
    tmp.color = color;
  }
  return React.createElement(EvergreenUi.Text, tmp);
}

var $$Text = {
  sizeToInt: sizeToInt$1,
  Binding: Binding$3,
  make: Evergreen$Text
};

function intentToStr$3(intent) {
  switch (intent) {
    case /* NoIntent */0 :
        return "none";
    case /* Success */1 :
        return "success";
    case /* Warning */2 :
        return "warning";
    case /* Danger */3 :
        return "danger";
    
  }
}

function appearanceToStr$2(appearance) {
  if (appearance) {
    return "card";
  } else {
    return "default";
  }
}

var Binding$4 = {};

function Evergreen$Alert(Props) {
  var children = Props.children;
  var intent = Props.intent;
  var hasIcon = Props.hasIcon;
  var isRemoveable = Props.isRemoveable;
  var onRemove = Props.onRemove;
  var title = Props.title;
  var appearance = Props.appearance;
  var intent$1 = unfold(intent, intentToStr$3);
  var appearance$1 = unfold(appearance, appearanceToStr$2);
  var tmp;
  tmp = children !== undefined ? children._0 : null;
  var tmp$1 = {
    children: tmp,
    title: title
  };
  if (intent$1 !== undefined) {
    tmp$1.intent = intent$1;
  }
  if (hasIcon !== undefined) {
    tmp$1.hasIcon = hasIcon;
  }
  if (isRemoveable !== undefined) {
    tmp$1.isRemoveable = isRemoveable;
  }
  if (onRemove !== undefined) {
    tmp$1.onRemove = Caml_option.valFromOption(onRemove);
  }
  if (appearance$1 !== undefined) {
    tmp$1.appearance = appearance$1;
  }
  return React.createElement(EvergreenUi.Alert, tmp$1);
}

var Alert = {
  intentToStr: intentToStr$3,
  appearanceToStr: appearanceToStr$2,
  Binding: Binding$4,
  make: Evergreen$Alert
};

var Head = {};

var Body = {};

var Row = {};

var Cell = {};

var TextCell = {};

var HeaderCell = {};

var TextHeaderCell = {};

var SearchHeaderCell = {};

var Table = {
  Head: Head,
  Body: Body,
  Row: Row,
  Cell: Cell,
  TextCell: TextCell,
  HeaderCell: HeaderCell,
  TextHeaderCell: TextHeaderCell,
  SearchHeaderCell: SearchHeaderCell
};

function intentToStr$4(intent) {
  switch (intent) {
    case /* NoIntent */0 :
        return "none";
    case /* Success */1 :
        return "success";
    case /* Warning */2 :
        return "warning";
    case /* Danger */3 :
        return "danger";
    
  }
}

var Binding$5 = {};

function Evergreen$Dialog(Props) {
  var children = Props.children;
  var intent = Props.intent;
  var isShown = Props.isShown;
  var title = Props.title;
  var hasHeader = Props.hasHeader;
  var header = Props.header;
  var hasFooter = Props.hasFooter;
  var footer = Props.footer;
  var hasCancel = Props.hasCancel;
  var hasClose = Props.hasClose;
  var onCloseComplete = Props.onCloseComplete;
  var onOpenComplete = Props.onOpenComplete;
  var onConfirm = Props.onConfirm;
  var onConfirmLabel = Props.onConfirmLabel;
  var isConfirmLoading = Props.isConfirmLoading;
  var isConfirmDisabled = Props.isConfirmDisabled;
  var onCancel = Props.onCancel;
  var cancelLabel = Props.cancelLabel;
  var shouldCloseOnOverlayClick = Props.shouldCloseOnOverlayClick;
  var shouldCloseOnEscapePress = Props.shouldCloseOnEscapePress;
  var width = Props.width;
  var topOffset = Props.topOffset;
  var sideOffset = Props.sideOffset;
  var minHeightContent = Props.minHeightContent;
  var preventBodyScrolling = Props.preventBodyScrolling;
  var intent$1 = unfold(intent, intentToStr$4);
  var tmp = {
    children: children
  };
  if (intent$1 !== undefined) {
    tmp.intent = intent$1;
  }
  if (isShown !== undefined) {
    tmp.isShown = isShown;
  }
  if (title !== undefined) {
    tmp.title = Caml_option.valFromOption(title);
  }
  if (hasHeader !== undefined) {
    tmp.hasHeader = hasHeader;
  }
  if (header !== undefined) {
    tmp.header = Caml_option.valFromOption(header);
  }
  if (hasFooter !== undefined) {
    tmp.hasFooter = hasFooter;
  }
  if (footer !== undefined) {
    tmp.footer = Caml_option.valFromOption(footer);
  }
  if (hasCancel !== undefined) {
    tmp.hasCancel = hasCancel;
  }
  if (hasClose !== undefined) {
    tmp.hasClose = hasClose;
  }
  if (onCloseComplete !== undefined) {
    tmp.onCloseComplete = Caml_option.valFromOption(onCloseComplete);
  }
  if (onOpenComplete !== undefined) {
    tmp.onOpenComplete = Caml_option.valFromOption(onOpenComplete);
  }
  if (onConfirm !== undefined) {
    tmp.onConfirm = Caml_option.valFromOption(onConfirm);
  }
  if (onConfirmLabel !== undefined) {
    tmp.onConfirmLabel = onConfirmLabel;
  }
  if (isConfirmLoading !== undefined) {
    tmp.isConfirmLoading = isConfirmLoading;
  }
  if (isConfirmDisabled !== undefined) {
    tmp.isConfirmDisabled = isConfirmDisabled;
  }
  if (onCancel !== undefined) {
    tmp.onCancel = Caml_option.valFromOption(onCancel);
  }
  if (cancelLabel !== undefined) {
    tmp.cancelLabel = cancelLabel;
  }
  if (shouldCloseOnOverlayClick !== undefined) {
    tmp.shouldCloseOnOverlayClick = shouldCloseOnOverlayClick;
  }
  if (shouldCloseOnEscapePress !== undefined) {
    tmp.shouldCloseOnEscapePress = shouldCloseOnEscapePress;
  }
  if (width !== undefined) {
    tmp.width = width;
  }
  if (topOffset !== undefined) {
    tmp.topOffset = topOffset;
  }
  if (sideOffset !== undefined) {
    tmp.sideOffset = sideOffset;
  }
  if (minHeightContent !== undefined) {
    tmp.minHeightContent = minHeightContent;
  }
  if (preventBodyScrolling !== undefined) {
    tmp.preventBodyScrolling = preventBodyScrolling;
  }
  return React.createElement(EvergreenUi.Dialog, tmp);
}

var Dialog = {
  intentToStr: intentToStr$4,
  Binding: Binding$5,
  make: Evergreen$Dialog
};

function positionToPos(position) {
  switch (position) {
    case /* Top */0 :
        return EvergreenUi.Position.TOP;
    case /* TopLeft */1 :
        return EvergreenUi.Position.TOP_LEFT;
    case /* TopRight */2 :
        return EvergreenUi.Position.TOP_RIGHT;
    case /* Bottom */3 :
        return EvergreenUi.Position.BOTTOM;
    case /* BottomLeft */4 :
        return EvergreenUi.Position.BOTTOM_LEFT;
    case /* BottomRight */5 :
        return EvergreenUi.Position.BOTTOM_RIGHT;
    case /* Left */6 :
        return EvergreenUi.Position.LEFT;
    case /* Right */7 :
        return EvergreenUi.Position.RIGHT;
    
  }
}

function triggerToStr(trigger) {
  if (trigger) {
    return "hover";
  } else {
    return "click";
  }
}

var FunctionBinding = {};

var ElemBinding = {};

function Evergreen$Popover(Props) {
  var position = Props.position;
  var isShown = Props.isShown;
  var trigger = Props.trigger;
  var content = Props.content;
  var children = Props.children;
  var display = Props.display;
  var minWidth = Props.minWidth;
  var minHeight = Props.minHeight;
  var animationDuration = Props.animationDuration;
  var onOpen = Props.onOpen;
  var onClose = Props.onClose;
  var onOpenComplete = Props.onOpenComplete;
  var onCloseComplete = Props.onCloseComplete;
  var onBodyClick = Props.onBodyClick;
  var bringFocusInside = Props.bringFocusInside;
  var shouldCloseOnExternalClick = Props.shouldCloseOnExternalClick;
  var trigger$1 = unfold(trigger, triggerToStr);
  var position$1 = unfold(position, positionToPos);
  var tmp = {
    content: content,
    children: children._0
  };
  if (position$1 !== undefined) {
    tmp.position = Caml_option.valFromOption(position$1);
  }
  if (isShown !== undefined) {
    tmp.isShown = isShown;
  }
  if (trigger$1 !== undefined) {
    tmp.trigger = trigger$1;
  }
  if (display !== undefined) {
    tmp.display = display;
  }
  if (minWidth !== undefined) {
    tmp.minWidth = minWidth;
  }
  if (minHeight !== undefined) {
    tmp.minHeight = minHeight;
  }
  if (animationDuration !== undefined) {
    tmp.animationDuration = animationDuration;
  }
  if (onOpen !== undefined) {
    tmp.onOpen = Caml_option.valFromOption(onOpen);
  }
  if (onClose !== undefined) {
    tmp.onClose = Caml_option.valFromOption(onClose);
  }
  if (onOpenComplete !== undefined) {
    tmp.onOpenComplete = Caml_option.valFromOption(onOpenComplete);
  }
  if (onCloseComplete !== undefined) {
    tmp.onCloseComplete = Caml_option.valFromOption(onCloseComplete);
  }
  if (onBodyClick !== undefined) {
    tmp.onBodyClick = Caml_option.valFromOption(onBodyClick);
  }
  if (bringFocusInside !== undefined) {
    tmp.bringFocusInside = bringFocusInside;
  }
  if (shouldCloseOnExternalClick !== undefined) {
    tmp.shouldCloseOnExternalClick = shouldCloseOnExternalClick;
  }
  return React.createElement(EvergreenUi.Popover, tmp);
}

var Popover = {
  positionToPos: positionToPos,
  triggerToStr: triggerToStr,
  FunctionBinding: FunctionBinding,
  ElemBinding: ElemBinding,
  make: Evergreen$Popover
};

function alignToStr(align) {
  switch (align) {
    case /* Stretch */0 :
        return "stretch";
    case /* Center */1 :
        return "center";
    case /* FlexStart */2 :
        return "flex-start";
    case /* FlexEnd */3 :
        return "flex-end";
    
  }
}

function elevationToInt(elevation) {
  return elevation;
}

var Binding$6 = {};

function Evergreen$Pane(Props) {
  var alignItems = Props.alignItems;
  var background = Props.background;
  var borderRadius = Props.borderRadius;
  var children = Props.children;
  var display = Props.display;
  var elevation = Props.elevation;
  var flexDirection = Props.flexDirection;
  var justifyContent = Props.justifyContent;
  var height = Props.height;
  var width = Props.width;
  var alignItems$1 = unfold(alignItems, alignToStr);
  var background$1 = unfold(background, colorToStr);
  var elevation$1 = unfold(elevation, elevationToInt);
  var tmp = {
    children: children
  };
  if (alignItems$1 !== undefined) {
    tmp.alignItems = alignItems$1;
  }
  if (background$1 !== undefined) {
    tmp.background = background$1;
  }
  if (borderRadius !== undefined) {
    tmp.borderRadius = borderRadius;
  }
  if (display !== undefined) {
    tmp.display = display;
  }
  if (elevation$1 !== undefined) {
    tmp.elevation = elevation$1;
  }
  if (flexDirection !== undefined) {
    tmp.flexDirection = flexDirection;
  }
  if (justifyContent !== undefined) {
    tmp.justifyContent = justifyContent;
  }
  if (height !== undefined) {
    tmp.height = height;
  }
  if (width !== undefined) {
    tmp.width = width;
  }
  return React.createElement(EvergreenUi.Pane, tmp);
}

var Pane = {
  alignToStr: alignToStr,
  elevationToInt: elevationToInt,
  Binding: Binding$6,
  make: Evergreen$Pane
};

function intentToStr$5(intent) {
  switch (intent) {
    case /* NoIntent */0 :
        return "none";
    case /* Success */1 :
        return "success";
    case /* Warning */2 :
        return "warning";
    case /* Danger */3 :
        return "danger";
    
  }
}

var Binding$7 = {};

function Evergreen$StatusIndicator$WithIntent(Props) {
  var children = Props.children;
  var intent = Props.intent;
  var dotSize = Props.dotSize;
  var intent$1 = intentToStr$5(intent);
  if (children !== undefined) {
    var tmp = {
      children: Caml_option.valFromOption(children),
      color: intent$1
    };
    if (dotSize !== undefined) {
      tmp.dotSize = dotSize;
    }
    return React.createElement(EvergreenUi.StatusIndicator, tmp);
  }
  var tmp$1 = {
    color: intent$1
  };
  if (dotSize !== undefined) {
    tmp$1.dotSize = dotSize;
  }
  return React.createElement(EvergreenUi.StatusIndicator, tmp$1);
}

var WithIntent = {
  make: Evergreen$StatusIndicator$WithIntent
};

function make(children, dotSize, color) {
  var color$1 = colorToStr(color);
  if (children !== undefined) {
    var tmp = {
      children: Caml_option.valFromOption(children),
      color: color$1
    };
    if (dotSize !== undefined) {
      tmp.dotSize = dotSize;
    }
    return React.createElement(EvergreenUi.StatusIndicator, tmp);
  }
  var tmp$1 = {
    color: color$1
  };
  if (dotSize !== undefined) {
    tmp$1.dotSize = dotSize;
  }
  return React.createElement(EvergreenUi.StatusIndicator, tmp$1);
}

var WithColor = {
  make: make
};

var StatusIndicator = {
  intentToStr: intentToStr$5,
  Binding: Binding$7,
  WithIntent: WithIntent,
  WithColor: WithColor
};

var Binding$8 = {};

function Evergreen$TextInput(Props) {
  var className = Props.className;
  var placeholder = Props.placeholder;
  var disabled = Props.disabled;
  var required = Props.required;
  var isInvalid = Props.isInvalid;
  var spellCheck = Props.spellCheck;
  var value = Props.value;
  var width = Props.width;
  var onChange = Props.onChange;
  var width$1 = width !== undefined ? width : "100%";
  var tmp = {
    width: width$1
  };
  if (className !== undefined) {
    tmp.className = className;
  }
  if (placeholder !== undefined) {
    tmp.placeholder = placeholder;
  }
  if (disabled !== undefined) {
    tmp.disabled = disabled;
  }
  if (required !== undefined) {
    tmp.required = required;
  }
  if (isInvalid !== undefined) {
    tmp.isInvalid = isInvalid;
  }
  if (value !== undefined) {
    tmp.value = value;
  }
  if (spellCheck !== undefined) {
    tmp.spellCheck = spellCheck;
  }
  if (onChange !== undefined) {
    tmp.onChange = Caml_option.valFromOption(onChange);
  }
  return React.createElement(EvergreenUi.TextInput, tmp);
}

var TextInput = {
  Binding: Binding$8,
  make: Evergreen$TextInput
};

var TextInputField = {};

export {
  unfold ,
  colorToStr ,
  Button ,
  IconButton ,
  CornerDialog ,
  Heading ,
  $$Text ,
  Alert ,
  Table ,
  Dialog ,
  Popover ,
  Pane ,
  StatusIndicator ,
  TextInput ,
  TextInputField ,
  
}
/* react Not a pure module */
